/*
 * GccApplication3.c
 *
 * Created: 18-10-2017 12:58:29
 *  Author: Lenovo T420
 */

#include <avr/io.h>
#include <stdlib.h>
#include <avr/sfr_defs.h>

#define F_CPU 16E6
//#define F_CPU 20000000
#include <util/delay.h>
#include <math.h>
 #include <avr/interrupt.h>
// output on USB = PD1 = board pin 1
// datasheet p.190; F_OSC = 16 MHz & baud rate = 19.200
#define UBBRVAL 51
char ADCOut[10];
int get_temp()
{
	int input = read_analog_pin(0);
	// converting that reading to voltage, for 3.3v arduino use 3.3
	float voltage = input * 5.0;
	voltage /= 1024.0;

	// now print out the temperature
	float temperatuur = (voltage - 0.5) * 100 ;  //to degrees ((voltage - 500mV) * 100)

	int intpart = floor(temperatuur);
	int decpart = ceil((temperatuur-intpart)*100);

	char buffer [100];
	int cx;
	cx = snprintf ( buffer, 100, "The temperature is %d.%d degrees C", intpart, decpart);
	return buffer;
}
int get_light()
{
		int input = read_analog_pin(1);
		float voltage = input * 5.0;
		//voltage /= 1024.0;

		int intpart = floor(voltage);
		char buffer [100];
		int cx;
		cx = snprintf ( buffer, 100, "The light level is %d lux oid", intpart);
	return buffer;
}
//returns the reading of the chosen analog pin
int read_analog_pin(pin){
	int tempPin = pin;
	uint8_t low, high;
	//lees input voltage
	ADMUX = (1 << 6) | (pin);
	// converteer naar een hexadecimaal getal
	ADCSRA |= 1<<ADPS0; 	//Set ADC prescaler to division factor of 128 (16,000,000/128,000 = 125Hz)
	ADCSRA |= 1<<ADPS1;
	ADCSRA |= 1<<ADPS2;

	ADCSRA |= _BV(ADEN);
	ADCSRA |= _BV(ADSC);
	while (bit_is_set(ADCSRA, ADSC));
	low  = ADCL;
	high = ADCH;

	// combine the two bytes
	int input = (high << 8) | low;
	return input;
}

#define TrigPin PIND4
#define EchoPin PIND2

volatile uint8_t pingState = 0;
volatile float echoInches = 0;
int get_distance()
{
	// Turn on timer with no prescaler on the clock for fastest
	// triggering of the interrupt service routine.
	TCCR1B = (1<<CS10);
	TIMSK1 = (1<<TOIE1);

	PCICR = (1<<PCIE2);
	PCMSK2 = (1<<PCINT18);

	DDRD = (1<<TrigPin);		// Set Pins As Output
	TCNT1 = 0;
	echoInches = 0;
	sei();
	while (pingState != 3)
	{
		switch (pingState){
			case 0:

				PORTD &= ~(1<<TrigPin);			// Set Trigger Pin To 0
				_delay_ms(1);					// Wait
				PORTD |= (1<<TrigPin);			// Set Trigger Pin To 1
				_delay_ms(1);					// Wait
				PORTD &= ~(1<<TrigPin);			// Set Trigger Pin To 0
				pingState++;					// Increment State
				break;
			case 1:
				// While In This Case, Do Nothing
				break;
			case 2:
				if(echoInches == -1){	// If Overflow Occured
					PORTD &= ~(1<<TrigPin);			// Set Trigger Pin To 0
					_delay_ms(1);					// Wait
					PORTD |= (1<<TrigPin);			// Set Trigger Pin To 1
					_delay_ms(1);					// Wait
					PORTD &= ~(1<<TrigPin);			// Set Trigger Pin To 0
					pingState = 1;					// Increment State
					//dit omdat hij de timer opnieuw laat lopen bij een overflow en ik niet weet hoe je hem uit zet
					break;
				}else{							// Otherwise

				}
				pingState++;					// Increment State
				break;
			}
	}
	pingState = 0;
	echoInches /= 1000;
	int intpart = floor(echoInches);
	int decpart = ceil((echoInches-intpart)*100);
	char buffer [100];
	int cx;
	cx = snprintf ( buffer, 100, "Shakespeare is %d.%d cm away", intpart, decpart);
	return buffer;
}

ISR(PCINT2_vect){
	if(PIND & (1<<EchoPin)){					// If EchoPin Is High
		TCNT1 = 0;								// Reset Timer
		TCCR1B |= (1<<CS10);					// Enable Timer
	}else{										// Othewise
		TCCR1B &= ~(1<<CS10);					// Disable Timer
		echoInches = TCNT1;//148;					// Count echoInches
		pingState = 2;							// Increment State
	}
}
ISR(TIMER1_OVF_vect){
	TCCR1B &= ~(1<<CS10);						// Enable Timer // hierdoor blijft hij (volgens mij) overflows genereren
	echoInches = -1;							// Set -1 As echoInches For Overflow
	pingState = 2;								// Increment State
}
int main(void)
{
	ser_init();
	_delay_ms(1000);

	DDRB=0; // read (pin 0+1)
	DDRD=4+8; // write (pin 2+3)
	PORTD|=4; // standaard één led aan

	char buffer[200];
	while(1) {
		ser_readln(buffer, 200);
		uint8_t ok=0;
		if (!strcmp(buffer, "hello")) {
			ser_writeln("IkBenEr!");
			ok=1;
		}
		if (!strcmp(buffer, "info")) {
			ser_writeln("Ledjes demo v1.0 Arduino (c)2017 MESM");
			ok=1;
		}
		if (!strcmp(buffer, "led1aan")) {
			PORTD|=4;
			ok=1;
		}
		if (!strcmp(buffer, "led1uit")) {
			PORTD&=~4;
			ok=1;
		}
		if (!strcmp(buffer, "led2aan")) {
			PORTD|=8;
			ok=1;
		}
		if (!strcmp(buffer, "led2uit")) {

			PORTD&=~8;
			ok=1;
		}
		if (!strcmp(buffer, "get_temp")) {
			ser_writeln(get_temp());
			ok=1;
		}
		if (!strcmp(buffer, "get_temp2")) {
			ser_writeln(buffer);
			ok=1;
		}

		if (!strcmp(buffer, "get_light")) {
			ser_writeln(get_light());
			ok=1;
		}
		if (!strcmp(buffer, "get_distance")) {
			ser_writeln(get_distance());
			ok=1;
		}
		if (!strcmp(buffer, "reset")) {
			main();

		}
		if (ok==0) {
			ser_writeln("Unknown command!");
		}
		if (ok==1) {
			ser_writeln("OK");
		} else {
			ser_writeln("ERR");
		}
	}
}
void transmit(uint8_t data)
{
	// wait for an empty transmit buffer
	// UDRE is set when the transmit buffer is empty
	loop_until_bit_is_set(UCSR0A, UDRE0);
	// send the data
	UDR0 = data;
}

void ser_writeln(const char* line){
	for(size_t i=0; i<strlen(line); i++){
		transmit(line[i]);
	}
	transmit('\n');
}
//UIT DE MAIL----------------------------------------
// Serial init functie, die zorgt voor data-transport in beide richtingen

void ser_init() {
	// Set baud rate
	UBRR0H = 0;
	UBRR0L = UBBRVAL;
	// disable U2X mode
	UCSR0A = 0;
	// enable TX and RX
	UCSR0B = _BV(RXEN0) | _BV(TXEN0);
	// set frame format: asynchronous, 8 data bits, 1 stop bit, no parity
	UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
}

// Serial read functie in C

char ser_read() {
	loop_until_bit_is_set(UCSR0A, RXC0); /* Wait until data exists. */
	return UDR0;
}

// Serial readln functie in C (van computer naar Arduino)
// Begrijp je wat deze functie doet?

void ser_readln(char *line, uint8_t bufsize) {
	uint8_t p=0;
	char c;
	do {
		c=ser_read();
		if (c!='\n') {
			line[p++]=c;
		}
		line[p]='\0';
	} while ((c!='\n') && (p<bufsize-1));
}